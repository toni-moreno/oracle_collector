# -*- toml -*-


[general]

log_dir = "./log"
#Log level for main log 
log_level = "debug"


[output]

buffer_size = 10000
flush_period = "10s"
#batch_size = 1000

[oracle-discovery]

oracle_discovery_interval = "5m"
oracle_discovery_sid_regex = "^[oraxe].*_pmon_(?P<SID>[\\w]+)$"

oracle_connect_user= "system"
oracle_connect_pass= "toni1234"
oracle_connect_dsn="192.168.1.84:1521/SID?transport_connect_timeout=5&retry_count=3"

extra_labels = {ifx_db="oracle_db",group="Exadata",release="Legacy"}

#Log level for all oracle interaction 
# trace,debug,info,warn/warning,error,fatal,panic
oracle_log_level = "debug"

[[oracle-discovery.dynamic-labels]]

sid_regex=".*P[0-9]$"
extra_labels={environment="PRO"}

[[oracle-discovery.dynamic-labels]]

sid_regex=".*R[0-9]$"
extra_labels={environment="PRE"}

[[oracle-discovery.dynamic-labels]]

sid_regex=".*D[0-9]$"
extra_labels={environment="DES"}

[[oracle-discovery.dynamic-labels]]

sid_regex=".*I[0-9]$"
extra_labels={environment="INT"}

[[oracle-discovery.dynamic-labels]]

sid_regex="^XE$"
extra_labels={environment="LAB"}

# [SystemMonitor]

# query_period = "60s"

# [[process_groups]]
# process_pattern = "DBWn"
# process_label = "DatabaseWritterProcess (DBWn)"

# [[process_groups]]
# process_pattern = "LGWR"
# process_label = "LogWriterProcess (LGWR)"

# [[process_groups]]
# process_pattern = "CKPT"
# process_label = "Checkpoint Process (CKPT)"

# [[process_groups]]
# process_pattern = "SMON"
# process_label = "System Monitor Process (SMON)"

# [[process_groups]]
# process_pattern = "PMON"
# process_label = "Process Monitor Process (PMON)"

# [[process_groups]]
# process_pattern = "RECO"
# process_label = "Recoverer Process (RECO)"

# [[process_groups]]
# process_pattern = "CJQ0,J[0-9]{3}"
# process_label = "Job Queue Processes"

# [[process_groups]]
# process_pattern = "ARC[0-9]{1}"
# process_label = "Archiver Processes"

# [[process_groups]]
# process_pattern = "QMN[0-9]{1}"
# process_label = "Queue Monitor Processes (QMNn)"


[oracle-monitor]

default_query_period = "60s"
default_query_timeout = "10s"

[[oracle-monitor.mgroup]]

name ="BaseMetrics"
query_period = "20s"
query_timeout = "5s"

[[oracle-monitor.mgroup.metric]]
context = "sessions"
labels = [ "status", "type" ]
metrics_desc = { value= "Gauge metric with count of sessions by status and type." }
metrics_type = { value='integer'}
request = "SELECT status, type, COUNT(*) as value FROM v$session GROUP BY status, type"

[[oracle-monitor.mgroup.metric]]
context = "resource"
labels = [ "resource_name" ]
metrics_desc = { current_utilization= "Generic counter metric from v$resource_limit view in Oracle (current value).", limit_value="Generic counter metric from v$resource_limit view in Oracle (UNLIMITED: -1)." }
metrics_type = { current_utilization='integer',limit_value='integer'}
request="SELECT resource_name,current_utilization,CASE WHEN TRIM(limit_value) LIKE 'UNLIMITED' THEN '-1' ELSE TRIM(limit_value) END as limit_value FROM v$resource_limit"

[[oracle-monitor.mgroup.metric]]
context = "activity"
metrics_desc = { value="Generic counter metric from v$sysstat view in Oracle." }
metrics_type = { value='integer'}
fieldtoappend = "name"
request = "SELECT name, value FROM v$sysstat WHERE name IN ('parse count (total)', 'execute count', 'user commits', 'user rollbacks')"

[[oracle-monitor.mgroup.metric]]
context = "process"
metrics_desc = { count="Gauge metric with count of processes." }
metrics_type = { count='integer'}
request = "SELECT COUNT(*) as count FROM v$process"

[[oracle-monitor.mgroup.metric]]
context = "wait_time"
metrics_desc = { value="Generic counter metric from v$waitclassmetric view in Oracle." }
metrics_type = { value='float'}
fieldtoappend= "wait_class"
request = '''
SELECT
  n.wait_class as WAIT_CLASS,
  round(m.time_waited/m.INTSIZE_CSEC,3) as VALUE
FROM
  v$waitclassmetric  m, v$system_wait_class n
WHERE
  m.wait_class_id=n.wait_class_id AND n.wait_class != 'Idle'
'''

[[oracle-monitor.mgroup.metric]]
context = "tablespace"
labels = [ "tablespace", "type" ]
metrics_desc = { bytes = "Generic counter metric of tablespaces bytes in Oracle.", max_bytes = "Generic counter metric of tablespaces max bytes in Oracle.", free = "Generic counter metric of tablespaces free bytes in Oracle.", used_percent = "Gauge metric showing as a percentage of how much of the tablespace has been used." }
metrics_type = { bytes = 'integer', max_bytes = 'integer', free='integer',used_percent='float'}
request = '''
SELECT
    dt.tablespace_name as tablespace,
    dt.contents as type,
    dt.block_size * dtum.used_space as bytes,
    dt.block_size * dtum.tablespace_size as max_bytes,
    dt.block_size * (dtum.tablespace_size - dtum.used_space) as free,
    dtum.used_percent
FROM  dba_tablespace_usage_metrics dtum, dba_tablespaces dt
WHERE dtum.tablespace_name = dt.tablespace_name
ORDER by tablespace
'''



[[oracle-monitor.mgroup]]

name ="AsmMetrics"
instance_filter = "ASM"
query_period = "60s"
query_timeout = "10s"

[[oracle-monitor.mgroup.metric]]
context = "asm_diskgroup"
labels = [ "name" ]
metrics_desc = { total = "Total size of ASM disk group.", free = "Free space available on ASM disk group." }
metrics_type = { total = 'integer', free = 'integer'}
request = "SELECT name,total_mb*1024*1024 as total,free_mb*1024*1024 as free FROM v$asm_diskgroup_stat where exists (select 1 from v$datafile where name like '+%')"
ignorezeroresult = true

[[oracle-monitor.mgroup.metric]]
context = "diskgroup_size"
labels = [ "inst_id", "node_name" , "instance_name", "diskgroup_name" ]
metrics_desc = { total = "Total size of ASM disk group in MB.", free = "Free space available on ASM disk group in MB." }
metrics_type = { total = 'integer', free='integer'}
request = '''
SELECT instance_number            AS inst_id,
       host_name                  AS node_name,
       instance_name,
       name                       AS diskgroup_name,
       total_mb * 1024 * 1024     AS total,
       free_mb * 1024 * 1024      AS free
  FROM v$asm_diskgroup_stat, v$instance
'''
ignorezeroresult = true

[[oracle-monitor.mgroup.metric]]
context = "asmuptime"
labels = [ "inst_id", "node_name", "instance_name"]
metrics_desc = { uptime = "ASM uptime" }
netrics_type = { uptime = 'integer'}
request = '''
SELECT instance_number                      AS inst_id,
       host_name                            AS node_name,
       instance_name,
       (SYSDATE - startup_time) * 86400     AS uptime
  FROM v$instance
'''

[[oracle-monitor.mgroup.metric]]
context = "asm_dg_stat"
labels = [ "inst_id", "diskgroup_name", "node_name", "instance_name" ]
metrics_desc = { reads = "Total number of I/O read requests for the DG.", writes = "Total number of I/O write requests for the DG.", bytes_read = "Total number of bytes read from the DG", bytes_written = "Total number of bytes written from the DG", iops = "Total number of I/O requests for the DG" }
metrics_type = { reads = "counter", writes = "counter", bytes_read = "counter", bytes_written = "counter", iops = "counter" }
request = '''
 SELECT i.instance_number              AS inst_id,
        i.host_name                    AS node_name,
        i.instance_name,
        g.name                         AS diskgroup_name,
        SUM (ds.reads)                 AS reads,
        SUM (ds.writes)                AS writes,
        SUM (ds.bytes_read)            AS bytes_read,
        SUM (ds.bytes_written)         AS bytes_written,
        SUM (ds.reads + ds.writes)     AS iops
   FROM v$asm_disk_stat ds, v$asm_diskgroup_stat g, v$instance i
  WHERE ds.mount_status = 'CACHED' AND ds.group_number = g.group_number
GROUP BY i.instance_number,
        i.host_name,
        i.instance_name,
        g.name
'''

[[oracle-monitor.mgroup.metric]]
context = "asm_disk_stat"
labels = [ "inst_id", "node_name", "instance_name", "diskgroup_name", "disk_number", "failgroup", "path" ]
metrics_desc = { reads = "Total number of I/O read requests for the DG.", writes = "Total number of I/O write requests for the DG.", read_time = "Total I/O time (in hundreths of a second) for read requests for the disk", write_time = "Total I/O time (in hundreths of a second) for write requests for the disk", bytes_read = "Total number of bytes read from the DG", bytes_written = "Total number of bytes written from the DG", iops = "Total number of I/O requests for the DG" }
metrics_type = { reads = "counter", writes = "counter", bytes_read = "counter", read_time = "counter", write_time = "counter", bytes_written = "counter", iops = "counter" }
request = '''
  SELECT i.instance_number                         AS inst_id,
         i.host_name                               AS node_name,
         i.instance_name,
         g.name                                    AS diskgroup_name,
         ds.disk_number                            AS disk_number,
         ds.failgroup                              AS failgroup,
         ds.reads                                  AS reads,
         ds.writes                                 AS writes,
         ds.read_time * 1000                       AS read_time,
         ds.write_time * 1000                      AS write_time,
         ds.bytes_read                             AS bytes_read,
         ds.bytes_written                          AS bytes_written,
         REGEXP_REPLACE (ds.PATH, '.*/\', '\')     AS PATH,
         ds.reads + ds.writes                      AS iops  
    FROM v$asm_disk_stat ds, v$asm_diskgroup_stat g, v$instance i
   WHERE ds.mount_status = 'CACHED' AND ds.group_number = g.group_number
'''

[[oracle-monitor.mgroup.metric]]
context = "asm_space_consumers"
labels = [ "inst_id", "diskgroup_name", "node_name", "instance_name", "sid", "file_type" ]
metrics_desc = { size_mb = "Total space usage by db by file_type" , files = "Number of files by db by type" }
metrics_type = { size_mb = 'integer', files ='integer'}
request = '''
  SELECT i.instance_number                     AS inst_id,
         i.host_name                           AS node_name,
         i.instance_name,
         gname                                 AS diskgroup_name,
         dbname                                AS sid,
         file_type,
         ROUND (SUM (space) / 1024 / 1024)     size_mb,
         COUNT (*)                             AS files
    FROM v$instance i,
         (SELECT gname,
                 REGEXP_SUBSTR (full_alias_path,
                                '[[:alnum:]_]*',
                                1,
                                4)    dbname,
                 file_type,
                 space,
                 aname,
                 system_created,
                 alias_directory
            FROM (    SELECT CONCAT ('+' || gname,
                                     SYS_CONNECT_BY_PATH (aname, '/'))
                                 full_alias_path,
                             system_created,
                             alias_directory,
                             file_type,
                             space,
                             LEVEL,
                             gname,
                             aname
                        FROM (SELECT b.name                gname,
                                     a.parent_index        pindex,
                                     a.name                aname,
                                     a.reference_index     rindex,
                                     a.system_created,
                                     a.alias_directory,
                                     c.TYPE                file_type,
                                     c.space
                                FROM v$asm_alias a, v$asm_diskgroup b, v$asm_file c
                               WHERE     a.group_number = b.group_number
                                     AND a.group_number = c.group_number(+)
                                     AND a.file_number = c.file_number(+)
                                     AND a.file_incarnation = c.incarnation(+))
                  START WITH     (MOD (pindex, POWER (2, 24))) = 0
                             AND rindex IN
                                     (SELECT a.reference_index
                                        FROM v$asm_alias a, v$asm_diskgroup b
                                       WHERE     a.group_number =
                                                 b.group_number
                                             AND (MOD (a.parent_index,
                                                       POWER (2, 24))) =
                                                 0)
                  CONNECT BY PRIOR rindex = pindex)
           WHERE NOT file_type IS NULL AND system_created = 'Y')
GROUP BY i.instance_number,
         i.host_name,
         i.instance_name,
         gname,
         dbname,
         file_type
'''

[[oracle-monitor.mgroup]]

name ="CustomMetrics"
query_period = "5m"
query_timeout = "5s"

[[oracle-monitor.mgroup.metric]]
context = "slow_queries"
metrics_desc = { p95_time_usecs= "Gauge metric with percentile 95 of elapsed time.", p99_time_usecs= "Gauge metric with percentile 99 of elapsed time." }
metrics_type = { p95_time_usecs='float', p99_time_usecs='float'}
request = "select  percentile_disc(0.95)  within group (order by elapsed_time) as p95_time_usecs, percentile_disc(0.99)  within group (order by elapsed_time) as p99_time_usecs from v$sql where last_active_time >= sysdate - 5/(24*60)"

[[oracle-monitor.mgroup.metric]]
context = "big_queries"
metrics_desc = { p95_rows= "Gauge metric with percentile 95 of returned rows.", p99_rows= "Gauge metric with percentile 99 of returned rows." }
metrics_type = { p95_rows= 'integer', p99_rows='integer'}
request = "select  percentile_disc(0.95)  within group (order by rownum) as p95_rows, percentile_disc(0.99)  within group (order by rownum) as p99_rows from v$sql where last_active_time >= sysdate - 5/(24*60)"

[[oracle-monitor.mgroup.metric]]
context = "size_user_segments_top100"
metrics_desc = {table_bytes="Gauge metric with the size of the tables in user segments."}
metrics_type = {table_bytes='integer'}
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as table_bytes from user_segments where segment_type='TABLE' group by segment_name) order by table_bytes DESC FETCH NEXT 100 ROWS ONLY"

[[oracle-monitor.mgroup.metric]]
context = "size_user_segments_top100"
metrics_desc = {table_partition_bytes="Gauge metric with the size of the table partition in user segments."}
metrics_type = {table_partition_bytes="integer"}
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as table_partition_bytes from user_segments where segment_type='TABLE PARTITION' group by segment_name) order by table_partition_bytes DESC FETCH NEXT 100 ROWS ONLY"

[[oracle-monitor.mgroup.metric]]
context = "size_user_segments_top100"
metrics_desc = {cluster_bytes="Gauge metric with the size of the cluster in user segments."}
metrics_type = {cluster_bytes='integer'}
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as cluster_bytes from user_segments where segment_type='CLUSTER' group by segment_name) order by cluster_bytes DESC FETCH NEXT 100 ROWS ONLY"

[[oracle-monitor.mgroup.metric]]
context = "size_dba_segments_top100"
metrics_desc = {table_bytes="Gauge metric with the size of the tables in dba segments."}
metrics_type = {table_bytes='integer'}
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as table_bytes from dba_segments where segment_type='TABLE' group by segment_name) order by table_bytes DESC FETCH NEXT 100 ROWS ONLY"

[[oracle-monitor.mgroup.metric]]
context = "size_dba_segments_top100"
metrics_desc = {table_partition_bytes="Gauge metric with the size of the table partition in dba segments."}
metrics_type = {table_partition_bytes='integer' }
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as table_partition_bytes from dba_segments where segment_type='TABLE PARTITION' group by segment_name) order by table_partition_bytes DESC FETCH NEXT 100 ROWS ONLY"

[[oracle-monitor.mgroup.metric]]
context = "size_dba_segments_top100"
metrics_desc = {cluster_bytes="Gauge metric with the size of the cluster in dba segments."}
metrics_type = {cluster_bytes='integer'}
labels = ["segment_name"]
request = "select * from (select segment_name,sum(bytes) as cluster_bytes from dba_segments where segment_type='CLUSTER' group by segment_name) order by cluster_bytes DESC FETCH NEXT 100 ROWS ONLY"
